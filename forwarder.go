// +build forwarder

package main

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"golang.org/x/sync/errgroup"
	"github.com/rs/zerolog/log"
)

func main() {
	lambda.Start(forward)
}

func getEndpoints() (map[string]string, error) {
	var pingAlarmARN, pingAlarmSlackHook string
	var ok bool

	pingAlarmARN, ok = os.LookupEnv("PING_ALARM_ARN")
	if !ok {
		return nil, errors.New("env var PING_ALARM_ARN not set")
	}

	pingAlarmSlackHook, ok = os.LookupEnv("PING_ALARM_SLACK_HOOK")
	if !ok {
		return nil, errors.New("env var PING_ALARM_SLACK_HOOK not set")
	}

	return map[string]string{
		pingAlarmARN: pingAlarmSlackHook,
	}, nil
}

func forward(ctx context.Context, evt events.SNSEvent) error {
	endpoints, err := getEndpoints()
	if err != nil {
		log.Error().Err(err).Send()
		return err
	}

	eg, childCtx := errgroup.WithContext(ctx)

	for _, record := range evt.Records {
		eg.Go(func() error {
			endpoint, ok := endpoints[record.SNS.TopicArn]
			if !ok {
				return fmt.Errorf("no endpoint exists to handle messages from topic: %s", record.SNS.TopicArn)
			}

			log.Info().Interface("record", record).Send()
			log.Info().Str("endpoint", endpoint).Str("topic", record.SNS.TopicArn).Send()
			alarm := &CloudWatchAlarm{}
			if err := json.Unmarshal([]byte(record.SNS.Message), alarm); err != nil {
				return err
			}

			// TODO: fill out this message
			msg := SlackMsg{
				Text:  alarm.AlarmDescription,
			}

			data, err := json.Marshal(&msg)
			if err != nil {
				log.Error().Err(err).Send()
				return err
			}

			req, err := http.NewRequest(http.MethodPost, endpoint, bytes.NewBuffer(data))
			if err != nil {
				log.Error().Err(err).Send()
				return err
			}

			req = req.WithContext(childCtx)

			client := http.DefaultClient
			client.Timeout = 5 * time.Second

			resp, err := client.Do(req)
			if err != nil {
				log.Error().Err(err).Send()
				return err
			}

			respData, _ := ioutil.ReadAll(resp.Body)
			defer resp.Body.Close()

			log.Info().RawJSON("respData", respData).Send()

			return nil
		})
	}

	return eg.Wait()
}

// all the structs below were generated by this tool: https://mholt.github.io/json-to-go/

type SlackMsg struct {
	Text   string   `json:"text"`
	Blocks []Blocks `json:"blocks"`
}

type Text struct {
	Type string `json:"type"`
	Text string `json:"text"`
}

type Accessory struct {
	Type     string `json:"type"`
	ImageURL string `json:"image_url"`
	AltText  string `json:"alt_text"`
}

type Fields struct {
	Type string `json:"type"`
	Text string `json:"text"`
}

type Blocks struct {
	Type      string    `json:"type"`
	Text      Text      `json:"text,omitempty"`
	BlockID   string    `json:"block_id,omitempty"`
	Accessory Accessory `json:"accessory,omitempty"`
	Fields    []Fields  `json:"fields,omitempty"`
}

type CloudWatchAlarm struct {
	AlarmName        string  `json:"AlarmName"`
	AlarmDescription string  `json:"AlarmDescription"`
	AWSAccountID     string  `json:"AWSAccountId"`
	NewStateValue    string  `json:"NewStateValue"`
	NewStateReason   string  `json:"NewStateReason"`
	StateChangeTime  string  `json:"StateChangeTime"`
	Region           string  `json:"Region"`
	OldStateValue    string  `json:"OldStateValue"`
	Trigger          Trigger `json:"Trigger"`
}

type Dimensions struct {
	Value string `json:"value"`
	Name  string `json:"name"`
}

type Trigger struct {
	MetricName                       string       `json:"MetricName"`
	Namespace                        string       `json:"Namespace"`
	StatisticType                    string       `json:"StatisticType"`
	Statistic                        string       `json:"Statistic"`
	Unit                             interface{}  `json:"Unit"`
	Dimensions                       []Dimensions `json:"Dimensions"`
	Period                           int          `json:"Period"`
	EvaluationPeriods                int          `json:"EvaluationPeriods"`
	ComparisonOperator               string       `json:"ComparisonOperator"`
	Threshold                        float64      `json:"Threshold"`
	TreatMissingData                 string       `json:"TreatMissingData"`
	EvaluateLowSampleCountPercentile string       `json:"EvaluateLowSampleCountPercentile"`
}
